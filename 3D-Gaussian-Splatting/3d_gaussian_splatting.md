## 1. 主要贡献

- 引入各向异性的3D高斯作为非结构化且高品质的辐射度场表示方法。
- 3D高斯的优化方法，通过交错使用自适应密度控制来生成高品质的场景表示。
- 快速可微分的GPU渲染方法，是一种基于可见性感知的方法，可以通过各向异性溅射和快速反向传播来实现高品质的新视口渲染。

## 2. 概述

本方法的输入数据是静态场景的一组照片集，通过SfM进行相机校准，依此产生一组稀疏点云。基于这些点，我们可以创建出一组3D高斯表示，每个表示由（平均）位置、协方差矩阵和不透明度α组成。这是一种合理且紧凑的表示，部分原因是高度的各向异性溅射可用于描述精细的结构。辐射度场的方向性表面（颜色）则是通过球谐表示。

我们的算法通过一系列步骤优化3D高斯参数，也就是位置、协方差、不透明度和球谐系数，并通过交错执行自适应控制高斯密度。

我们算法高效的关键在于基于分片的光栅化器通过可见性快速排序可以实现高效的各向异性溅射的透明混合。该光栅化器也实现了一个通过跟踪累积不透明度α数值的快速反向pass。

## 3. 实现

### 3.1 可微的3D高斯溅射

为了表示三维场景，我们需要一种图元来替代可微体积的场景表示，同时希望它可以是显式表达以支持快速渲染。我们选择了3D高斯的表示方法，它是可微的，而且很容易投影到二维溅射以实现渲染中的快速透明混合。

前人的3D高斯表示方法假定了每个点都是一个带法线的小圆片。鉴于SfM的极端稀疏性，实际上很难估计法线。同样的，对于噪声很大的法线做优化也很困难。取而代之的，我们使用一组不需要法线的3D高斯来建模几何信息。它由一个定义在世界空间中且以点$\mu$为中心的3D协方差矩阵描述：

$$G(x)=e^{-\frac{1}{2}(x)^T\Sigma^{-1}(x)}$$

渲染时需要将3D高斯投影到二维。Zwicker等人的论文展示了如何进行这样的投影。给定一个视口变换W，那么相机坐标下相应的协方差矩阵为：

$$\Sigma'=JW\Sigma W^TJ^T$$

其中，$J$是投影变换矩阵进行仿射近似的雅克比矩阵。

一个显然的优化方法是直接优化3D高斯的这个协方差矩阵。但是协方差矩阵只有在满足半正定的时候才具有物理意义，对于我们的优化过程来说，如果使用梯度下降就不一定能满足这样的有效性约束。

最终，我们选择了一种更直观也更容易表达的方式来进行优化。3D高斯中的协方差矩阵类似于描述椭球体的形状。给定一个缩放矩阵$S$和一个旋转矩阵$R$，我们可以找到一个相应的协方差矩阵$\Sigma$：

$$\Sigma=RSS^TR^T$$

为了能单独优化这两项，我们分别存储它们：使用一个三维向量$s$存储缩放，使用一个四元数$q$存储旋转（需要归一化）。

为了避免训练过程中自动微分产生大量的开销，我们事先显式推导出所有参数的梯度（附录A）。

上述各向异性协方差的表示适合于优化，这允许我们优化三维高斯分布以适应场景中不同形状的几何形状，从而产生一个紧凑的表示。

### 3.2 3D高斯的自适应密度控制

本文的核心在于优化过程，也就是创建一组3D高斯来精确描述场景以供自由浏览。需要优化的参数包括位置$p$，不透明度$\alpha$，协方差矩阵$\Sigma$，以及表示各方向颜色的球谐系数。参数的优化过程中会交错地使用密度控制来获得更好的场景表示。

优化过程就是对渲染结果和照片比较结果的多次迭代。由于3D到2D的投影过程，不可避免地需要对几何体进行创建、销毁或移动。3D高斯中协方差矩阵的参数质量是影响紧凑性的关键因素。因为大的均匀区域可以通过少数几个大的各向异性高斯描述。

我们使用随机梯度下降进行优化，并遵循最佳实现，充分利用GPU加速。实际上，我们的快速光栅化方法是优化过程的关键，因为它是整个优化过程的性能瓶颈。

我们使用Sigmoid激活函数将$\alpha$参数约束在[0,1)区间并保持光滑梯度，对协方差的尺度则使用指数激活函数。

我们将初始的协方差矩阵当作各向同性的高斯，各个轴等同于到最近三个点的平均距离。我们使用一种类似于Plenoxels的标准指数衰减调度，但只用在位置参数上。损失函数则结合了D-SSIM项（结构相似性）：

$$\mathcal{L}=(1-\lambda)\mathcal{L}_1+\lambda\mathcal{L}_{D-SSIM}$$

其中，我们使用$\lambda=0.2$。

---

使用SfM初始化了一组稀疏点后，我们的方法会在单位体积上自适应地控制高斯的数量（密度），这样就能从初始的稀疏高斯逐渐变为稠密的场景表示。在优化过程预热结束后，我们每100次迭代密集化一次，并删除任何本质上是透明的高斯（也就是不透明度低于阈值$\epsilon_\alpha$）。

高斯的自适应控制需要填充空白的区域。我们既需要关注缺失几何特征（欠重建）的区域，也要关注单个高斯覆盖较大（过重建）的区域。我们注意到两者都具有大尺度的视角空间的位置梯度。直觉上，这很可能是未能很好地重建所引起的，因此，优化器会选择移除这些高斯点来修正该问题。

鉴于这是一个很合适的时间，我们选择在视角空间位置梯度的平均值大于阈值$\tau_{pos}$（我们取值0.0002）时，密集化高斯点云。

对于欠重建区域的小高斯点，我们需要新建高斯点来覆盖几何形状。因此，算法倾向于复制当前高斯点并将其沿位置梯度方向移动。反之，对于高方差的大高斯点（过重建区域），我们需要将它拆分成两个小高斯点，尺度上除以$\phi=1.6$，位置则是依据原始的3D高斯作为PDF进行采样。

与其他体积表示方法类似，靠近镜头的小物体可能会引起高斯点云密度的过度提高。一种缓解方案是在每3000轮迭代后将不透明度$\alpha$的设置为一个接近零的极小值，这之后，优化器会逐渐提高所需高斯点的不透明度，同时裁剪掉较低不透明度的高斯点。

### 3.3 高斯点的快速可微分光栅化器

从软光栅得到灵感，我们设计了一种基于分片的光栅化器。先对整个图像的图元做一次预排序，以避免逐像素排序的开销，但这破坏了以前的透明混合方案。我们的快速光栅化器支持在任意数量的混合高斯上做高效的反向传播，而只增加一点点内存开销。我们的光栅化管线是完全可微的，且当给定二维投影后，可以光栅化出与之前2D溅射方法相似的各向异性溅射。

我们的方法首先将屏幕划分为16*16个分片，并根据视锥体裁剪3D高斯点云。具体而言，我们只保留与视锥体具有99%置信度重合的高斯点云。另外，我们使用一个守护带来避免极端位置上的高斯点（也就是离裁剪平面很近的高斯点，这些位置上计算出来的二维协方差并不稳定）。

接下来，我们将高斯点按照覆盖的分片数量初始化，并为每个高斯点分配一个结合了视角空间深度和分片ID的键值。依据这些键值，我们就可以使用快速GPU基数排序处理高斯点的排序。注意，这里不需要额外的逐像素排序，透明混合也可以在初始排序上进行。我们发现这样的处理可以大大提高训练和渲染的性能而不会引入场景伪影。

当对高斯点云排完序后，我们基于最近和最远深度为每个分片生成一个列表。当执行光栅化时，每个分片使用一个线程组，每个线程组先将分片上的高斯点云加载到内存中，然后从前往后遍历列表来累积像素的颜色和不透明度，当某个像素上累积的不透明度达到上限时就停止。

在反向pass中，我们必须恢复正向pass中所混合的高斯点的序列。一种方案是将这些逐像素混合的点以列表的形式存储在一个全局内存空间中。为了避免动态内存分配的开销，我们选择重新遍历一遍。